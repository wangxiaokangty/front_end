{"ast":null,"code":"'use strict';\n\n/* eslint-disable no-bitwise */\nrequire(\"core-js/modules/es.array.push.js\");\nconst decodeCache = {};\nfunction getDecodeCache(exclude) {\n  let cache = decodeCache[exclude];\n  if (cache) {\n    return cache;\n  }\n  cache = decodeCache[exclude] = [];\n  for (let i = 0; i < 128; i++) {\n    const ch = String.fromCharCode(i);\n    cache.push(ch);\n  }\n  for (let i = 0; i < exclude.length; i++) {\n    const ch = exclude.charCodeAt(i);\n    cache[ch] = '%' + ('0' + ch.toString(16).toUpperCase()).slice(-2);\n  }\n  return cache;\n}\n\n// Decode percent-encoded string.\n//\nfunction decode(string, exclude) {\n  if (typeof exclude !== 'string') {\n    exclude = decode.defaultChars;\n  }\n  const cache = getDecodeCache(exclude);\n  return string.replace(/(%[a-f0-9]{2})+/gi, function (seq) {\n    let result = '';\n    for (let i = 0, l = seq.length; i < l; i += 3) {\n      const b1 = parseInt(seq.slice(i + 1, i + 3), 16);\n      if (b1 < 0x80) {\n        result += cache[b1];\n        continue;\n      }\n      if ((b1 & 0xE0) === 0xC0 && i + 3 < l) {\n        // 110xxxxx 10xxxxxx\n        const b2 = parseInt(seq.slice(i + 4, i + 6), 16);\n        if ((b2 & 0xC0) === 0x80) {\n          const chr = b1 << 6 & 0x7C0 | b2 & 0x3F;\n          if (chr < 0x80) {\n            result += '\\ufffd\\ufffd';\n          } else {\n            result += String.fromCharCode(chr);\n          }\n          i += 3;\n          continue;\n        }\n      }\n      if ((b1 & 0xF0) === 0xE0 && i + 6 < l) {\n        // 1110xxxx 10xxxxxx 10xxxxxx\n        const b2 = parseInt(seq.slice(i + 4, i + 6), 16);\n        const b3 = parseInt(seq.slice(i + 7, i + 9), 16);\n        if ((b2 & 0xC0) === 0x80 && (b3 & 0xC0) === 0x80) {\n          const chr = b1 << 12 & 0xF000 | b2 << 6 & 0xFC0 | b3 & 0x3F;\n          if (chr < 0x800 || chr >= 0xD800 && chr <= 0xDFFF) {\n            result += '\\ufffd\\ufffd\\ufffd';\n          } else {\n            result += String.fromCharCode(chr);\n          }\n          i += 6;\n          continue;\n        }\n      }\n      if ((b1 & 0xF8) === 0xF0 && i + 9 < l) {\n        // 111110xx 10xxxxxx 10xxxxxx 10xxxxxx\n        const b2 = parseInt(seq.slice(i + 4, i + 6), 16);\n        const b3 = parseInt(seq.slice(i + 7, i + 9), 16);\n        const b4 = parseInt(seq.slice(i + 10, i + 12), 16);\n        if ((b2 & 0xC0) === 0x80 && (b3 & 0xC0) === 0x80 && (b4 & 0xC0) === 0x80) {\n          let chr = b1 << 18 & 0x1C0000 | b2 << 12 & 0x3F000 | b3 << 6 & 0xFC0 | b4 & 0x3F;\n          if (chr < 0x10000 || chr > 0x10FFFF) {\n            result += '\\ufffd\\ufffd\\ufffd\\ufffd';\n          } else {\n            chr -= 0x10000;\n            result += String.fromCharCode(0xD800 + (chr >> 10), 0xDC00 + (chr & 0x3FF));\n          }\n          i += 9;\n          continue;\n        }\n      }\n      result += '\\ufffd';\n    }\n    return result;\n  });\n}\ndecode.defaultChars = ';/?:@&=+$,#';\ndecode.componentChars = '';\nconst encodeCache = {};\n\n// Create a lookup array where anything but characters in `chars` string\n// and alphanumeric chars is percent-encoded.\n//\nfunction getEncodeCache(exclude) {\n  let cache = encodeCache[exclude];\n  if (cache) {\n    return cache;\n  }\n  cache = encodeCache[exclude] = [];\n  for (let i = 0; i < 128; i++) {\n    const ch = String.fromCharCode(i);\n    if (/^[0-9a-z]$/i.test(ch)) {\n      // always allow unencoded alphanumeric characters\n      cache.push(ch);\n    } else {\n      cache.push('%' + ('0' + i.toString(16).toUpperCase()).slice(-2));\n    }\n  }\n  for (let i = 0; i < exclude.length; i++) {\n    cache[exclude.charCodeAt(i)] = exclude[i];\n  }\n  return cache;\n}\n\n// Encode unsafe characters with percent-encoding, skipping already\n// encoded sequences.\n//\n//  - string       - string to encode\n//  - exclude      - list of characters to ignore (in addition to a-zA-Z0-9)\n//  - keepEscaped  - don't encode '%' in a correct escape sequence (default: true)\n//\nfunction encode(string, exclude, keepEscaped) {\n  if (typeof exclude !== 'string') {\n    // encode(string, keepEscaped)\n    keepEscaped = exclude;\n    exclude = encode.defaultChars;\n  }\n  if (typeof keepEscaped === 'undefined') {\n    keepEscaped = true;\n  }\n  const cache = getEncodeCache(exclude);\n  let result = '';\n  for (let i = 0, l = string.length; i < l; i++) {\n    const code = string.charCodeAt(i);\n    if (keepEscaped && code === 0x25 /* % */ && i + 2 < l) {\n      if (/^[0-9a-f]{2}$/i.test(string.slice(i + 1, i + 3))) {\n        result += string.slice(i, i + 3);\n        i += 2;\n        continue;\n      }\n    }\n    if (code < 128) {\n      result += cache[code];\n      continue;\n    }\n    if (code >= 0xD800 && code <= 0xDFFF) {\n      if (code >= 0xD800 && code <= 0xDBFF && i + 1 < l) {\n        const nextCode = string.charCodeAt(i + 1);\n        if (nextCode >= 0xDC00 && nextCode <= 0xDFFF) {\n          result += encodeURIComponent(string[i] + string[i + 1]);\n          i++;\n          continue;\n        }\n      }\n      result += '%EF%BF%BD';\n      continue;\n    }\n    result += encodeURIComponent(string[i]);\n  }\n  return result;\n}\nencode.defaultChars = \";/?:@&=+$,-_.!~*'()#\";\nencode.componentChars = \"-_.!~*'()\";\nfunction format(url) {\n  let result = '';\n  result += url.protocol || '';\n  result += url.slashes ? '//' : '';\n  result += url.auth ? url.auth + '@' : '';\n  if (url.hostname && url.hostname.indexOf(':') !== -1) {\n    // ipv6 address\n    result += '[' + url.hostname + ']';\n  } else {\n    result += url.hostname || '';\n  }\n  result += url.port ? ':' + url.port : '';\n  result += url.pathname || '';\n  result += url.search || '';\n  result += url.hash || '';\n  return result;\n}\n\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n//\n// Changes from joyent/node:\n//\n// 1. No leading slash in paths,\n//    e.g. in `url.parse('http://foo?bar')` pathname is ``, not `/`\n//\n// 2. Backslashes are not replaced with slashes,\n//    so `http:\\\\example.org\\` is treated like a relative path\n//\n// 3. Trailing colon is treated like a part of the path,\n//    i.e. in `http://example.org:foo` pathname is `:foo`\n//\n// 4. Nothing is URL-encoded in the resulting object,\n//    (in joyent/node some chars in auth and paths are encoded)\n//\n// 5. `url.parse()` does not have `parseQueryString` argument\n//\n// 6. Removed extraneous result properties: `host`, `path`, `query`, etc.,\n//    which can be constructed using other parts of the url.\n//\n\nfunction Url() {\n  this.protocol = null;\n  this.slashes = null;\n  this.auth = null;\n  this.port = null;\n  this.hostname = null;\n  this.hash = null;\n  this.search = null;\n  this.pathname = null;\n}\n\n// Reference: RFC 3986, RFC 1808, RFC 2396\n\n// define these here so at least they only have to be\n// compiled once on the first module load.\nconst protocolPattern = /^([a-z0-9.+-]+:)/i;\nconst portPattern = /:[0-9]*$/;\n\n// Special case for a simple path URL\n/* eslint-disable-next-line no-useless-escape */\nconst simplePathPattern = /^(\\/\\/?(?!\\/)[^\\?\\s]*)(\\?[^\\s]*)?$/;\n\n// RFC 2396: characters reserved for delimiting URLs.\n// We actually just auto-escape these.\nconst delims = ['<', '>', '\"', '`', ' ', '\\r', '\\n', '\\t'];\n\n// RFC 2396: characters not allowed for various reasons.\nconst unwise = ['{', '}', '|', '\\\\', '^', '`'].concat(delims);\n\n// Allowed by RFCs, but cause of XSS attacks.  Always escape these.\nconst autoEscape = ['\\''].concat(unwise);\n// Characters that are never ever allowed in a hostname.\n// Note that any invalid chars are also handled, but these\n// are the ones that are *expected* to be seen, so we fast-path\n// them.\nconst nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape);\nconst hostEndingChars = ['/', '?', '#'];\nconst hostnameMaxLen = 255;\nconst hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/;\nconst hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/;\n// protocols that can allow \"unsafe\" and \"unwise\" chars.\n// protocols that never have a hostname.\nconst hostlessProtocol = {\n  javascript: true,\n  'javascript:': true\n};\n// protocols that always contain a // bit.\nconst slashedProtocol = {\n  http: true,\n  https: true,\n  ftp: true,\n  gopher: true,\n  file: true,\n  'http:': true,\n  'https:': true,\n  'ftp:': true,\n  'gopher:': true,\n  'file:': true\n};\nfunction urlParse(url, slashesDenoteHost) {\n  if (url && url instanceof Url) return url;\n  const u = new Url();\n  u.parse(url, slashesDenoteHost);\n  return u;\n}\nUrl.prototype.parse = function (url, slashesDenoteHost) {\n  let lowerProto, hec, slashes;\n  let rest = url;\n\n  // trim before proceeding.\n  // This is to support parse stuff like \"  http://foo.com  \\n\"\n  rest = rest.trim();\n  if (!slashesDenoteHost && url.split('#').length === 1) {\n    // Try fast path regexp\n    const simplePath = simplePathPattern.exec(rest);\n    if (simplePath) {\n      this.pathname = simplePath[1];\n      if (simplePath[2]) {\n        this.search = simplePath[2];\n      }\n      return this;\n    }\n  }\n  let proto = protocolPattern.exec(rest);\n  if (proto) {\n    proto = proto[0];\n    lowerProto = proto.toLowerCase();\n    this.protocol = proto;\n    rest = rest.substr(proto.length);\n  }\n\n  // figure out if it's got a host\n  // user@server is *always* interpreted as a hostname, and url\n  // resolution will treat //foo/bar as host=foo,path=bar because that's\n  // how the browser resolves relative URLs.\n  /* eslint-disable-next-line no-useless-escape */\n  if (slashesDenoteHost || proto || rest.match(/^\\/\\/[^@\\/]+@[^@\\/]+/)) {\n    slashes = rest.substr(0, 2) === '//';\n    if (slashes && !(proto && hostlessProtocol[proto])) {\n      rest = rest.substr(2);\n      this.slashes = true;\n    }\n  }\n  if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {\n    // there's a hostname.\n    // the first instance of /, ?, ;, or # ends the host.\n    //\n    // If there is an @ in the hostname, then non-host chars *are* allowed\n    // to the left of the last @ sign, unless some host-ending character\n    // comes *before* the @-sign.\n    // URLs are obnoxious.\n    //\n    // ex:\n    // http://a@b@c/ => user:a@b host:c\n    // http://a@b?@c => user:a host:c path:/?@c\n\n    // v0.12 TODO(isaacs): This is not quite how Chrome does things.\n    // Review our test case against browsers more comprehensively.\n\n    // find the first instance of any hostEndingChars\n    let hostEnd = -1;\n    for (let i = 0; i < hostEndingChars.length; i++) {\n      hec = rest.indexOf(hostEndingChars[i]);\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {\n        hostEnd = hec;\n      }\n    }\n\n    // at this point, either we have an explicit point where the\n    // auth portion cannot go past, or the last @ char is the decider.\n    let auth, atSign;\n    if (hostEnd === -1) {\n      // atSign can be anywhere.\n      atSign = rest.lastIndexOf('@');\n    } else {\n      // atSign must be in auth portion.\n      // http://a@b/c@d => host:b auth:a path:/c@d\n      atSign = rest.lastIndexOf('@', hostEnd);\n    }\n\n    // Now we have a portion which is definitely the auth.\n    // Pull that off.\n    if (atSign !== -1) {\n      auth = rest.slice(0, atSign);\n      rest = rest.slice(atSign + 1);\n      this.auth = auth;\n    }\n\n    // the host is the remaining to the left of the first non-host char\n    hostEnd = -1;\n    for (let i = 0; i < nonHostChars.length; i++) {\n      hec = rest.indexOf(nonHostChars[i]);\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {\n        hostEnd = hec;\n      }\n    }\n    // if we still have not hit it, then the entire thing is a host.\n    if (hostEnd === -1) {\n      hostEnd = rest.length;\n    }\n    if (rest[hostEnd - 1] === ':') {\n      hostEnd--;\n    }\n    const host = rest.slice(0, hostEnd);\n    rest = rest.slice(hostEnd);\n\n    // pull out port.\n    this.parseHost(host);\n\n    // we've indicated that there is a hostname,\n    // so even if it's empty, it has to be present.\n    this.hostname = this.hostname || '';\n\n    // if hostname begins with [ and ends with ]\n    // assume that it's an IPv6 address.\n    const ipv6Hostname = this.hostname[0] === '[' && this.hostname[this.hostname.length - 1] === ']';\n\n    // validate a little.\n    if (!ipv6Hostname) {\n      const hostparts = this.hostname.split(/\\./);\n      for (let i = 0, l = hostparts.length; i < l; i++) {\n        const part = hostparts[i];\n        if (!part) {\n          continue;\n        }\n        if (!part.match(hostnamePartPattern)) {\n          let newpart = '';\n          for (let j = 0, k = part.length; j < k; j++) {\n            if (part.charCodeAt(j) > 127) {\n              // we replace non-ASCII char with a temporary placeholder\n              // we need this to make sure size of hostname is not\n              // broken by replacing non-ASCII by nothing\n              newpart += 'x';\n            } else {\n              newpart += part[j];\n            }\n          }\n          // we test again with ASCII char only\n          if (!newpart.match(hostnamePartPattern)) {\n            const validParts = hostparts.slice(0, i);\n            const notHost = hostparts.slice(i + 1);\n            const bit = part.match(hostnamePartStart);\n            if (bit) {\n              validParts.push(bit[1]);\n              notHost.unshift(bit[2]);\n            }\n            if (notHost.length) {\n              rest = notHost.join('.') + rest;\n            }\n            this.hostname = validParts.join('.');\n            break;\n          }\n        }\n      }\n    }\n    if (this.hostname.length > hostnameMaxLen) {\n      this.hostname = '';\n    }\n\n    // strip [ and ] from the hostname\n    // the host field still retains them, though\n    if (ipv6Hostname) {\n      this.hostname = this.hostname.substr(1, this.hostname.length - 2);\n    }\n  }\n\n  // chop off from the tail first.\n  const hash = rest.indexOf('#');\n  if (hash !== -1) {\n    // got a fragment string.\n    this.hash = rest.substr(hash);\n    rest = rest.slice(0, hash);\n  }\n  const qm = rest.indexOf('?');\n  if (qm !== -1) {\n    this.search = rest.substr(qm);\n    rest = rest.slice(0, qm);\n  }\n  if (rest) {\n    this.pathname = rest;\n  }\n  if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {\n    this.pathname = '';\n  }\n  return this;\n};\nUrl.prototype.parseHost = function (host) {\n  let port = portPattern.exec(host);\n  if (port) {\n    port = port[0];\n    if (port !== ':') {\n      this.port = port.substr(1);\n    }\n    host = host.substr(0, host.length - port.length);\n  }\n  if (host) {\n    this.hostname = host;\n  }\n};\nexports.decode = decode;\nexports.encode = encode;\nexports.format = format;\nexports.parse = urlParse;","map":{"version":3,"names":["require","decodeCache","getDecodeCache","exclude","cache","i","ch","String","fromCharCode","push","length","charCodeAt","toString","toUpperCase","slice","decode","string","defaultChars","replace","seq","result","l","b1","parseInt","b2","chr","b3","b4","componentChars","encodeCache","getEncodeCache","test","encode","keepEscaped","code","nextCode","encodeURIComponent","format","url","protocol","slashes","auth","hostname","indexOf","port","pathname","search","hash","Url","protocolPattern","portPattern","simplePathPattern","delims","unwise","concat","autoEscape","nonHostChars","hostEndingChars","hostnameMaxLen","hostnamePartPattern","hostnamePartStart","hostlessProtocol","javascript","slashedProtocol","http","https","ftp","gopher","file","urlParse","slashesDenoteHost","u","parse","prototype","lowerProto","hec","rest","trim","split","simplePath","exec","proto","toLowerCase","substr","match","hostEnd","atSign","lastIndexOf","host","parseHost","ipv6Hostname","hostparts","part","newpart","j","k","validParts","notHost","bit","unshift","join","qm","exports"],"sources":["/Users/wangxiaokang/Desktop/SpringBoot/vue-project/node_modules/mdurl/build/index.cjs.js"],"sourcesContent":["'use strict';\n\n/* eslint-disable no-bitwise */\n\nconst decodeCache = {};\n\nfunction getDecodeCache (exclude) {\n  let cache = decodeCache[exclude];\n  if (cache) { return cache }\n\n  cache = decodeCache[exclude] = [];\n\n  for (let i = 0; i < 128; i++) {\n    const ch = String.fromCharCode(i);\n    cache.push(ch);\n  }\n\n  for (let i = 0; i < exclude.length; i++) {\n    const ch = exclude.charCodeAt(i);\n    cache[ch] = '%' + ('0' + ch.toString(16).toUpperCase()).slice(-2);\n  }\n\n  return cache\n}\n\n// Decode percent-encoded string.\n//\nfunction decode (string, exclude) {\n  if (typeof exclude !== 'string') {\n    exclude = decode.defaultChars;\n  }\n\n  const cache = getDecodeCache(exclude);\n\n  return string.replace(/(%[a-f0-9]{2})+/gi, function (seq) {\n    let result = '';\n\n    for (let i = 0, l = seq.length; i < l; i += 3) {\n      const b1 = parseInt(seq.slice(i + 1, i + 3), 16);\n\n      if (b1 < 0x80) {\n        result += cache[b1];\n        continue\n      }\n\n      if ((b1 & 0xE0) === 0xC0 && (i + 3 < l)) {\n        // 110xxxxx 10xxxxxx\n        const b2 = parseInt(seq.slice(i + 4, i + 6), 16);\n\n        if ((b2 & 0xC0) === 0x80) {\n          const chr = ((b1 << 6) & 0x7C0) | (b2 & 0x3F);\n\n          if (chr < 0x80) {\n            result += '\\ufffd\\ufffd';\n          } else {\n            result += String.fromCharCode(chr);\n          }\n\n          i += 3;\n          continue\n        }\n      }\n\n      if ((b1 & 0xF0) === 0xE0 && (i + 6 < l)) {\n        // 1110xxxx 10xxxxxx 10xxxxxx\n        const b2 = parseInt(seq.slice(i + 4, i + 6), 16);\n        const b3 = parseInt(seq.slice(i + 7, i + 9), 16);\n\n        if ((b2 & 0xC0) === 0x80 && (b3 & 0xC0) === 0x80) {\n          const chr = ((b1 << 12) & 0xF000) | ((b2 << 6) & 0xFC0) | (b3 & 0x3F);\n\n          if (chr < 0x800 || (chr >= 0xD800 && chr <= 0xDFFF)) {\n            result += '\\ufffd\\ufffd\\ufffd';\n          } else {\n            result += String.fromCharCode(chr);\n          }\n\n          i += 6;\n          continue\n        }\n      }\n\n      if ((b1 & 0xF8) === 0xF0 && (i + 9 < l)) {\n        // 111110xx 10xxxxxx 10xxxxxx 10xxxxxx\n        const b2 = parseInt(seq.slice(i + 4, i + 6), 16);\n        const b3 = parseInt(seq.slice(i + 7, i + 9), 16);\n        const b4 = parseInt(seq.slice(i + 10, i + 12), 16);\n\n        if ((b2 & 0xC0) === 0x80 && (b3 & 0xC0) === 0x80 && (b4 & 0xC0) === 0x80) {\n          let chr = ((b1 << 18) & 0x1C0000) | ((b2 << 12) & 0x3F000) | ((b3 << 6) & 0xFC0) | (b4 & 0x3F);\n\n          if (chr < 0x10000 || chr > 0x10FFFF) {\n            result += '\\ufffd\\ufffd\\ufffd\\ufffd';\n          } else {\n            chr -= 0x10000;\n            result += String.fromCharCode(0xD800 + (chr >> 10), 0xDC00 + (chr & 0x3FF));\n          }\n\n          i += 9;\n          continue\n        }\n      }\n\n      result += '\\ufffd';\n    }\n\n    return result\n  })\n}\n\ndecode.defaultChars = ';/?:@&=+$,#';\ndecode.componentChars = '';\n\nconst encodeCache = {};\n\n// Create a lookup array where anything but characters in `chars` string\n// and alphanumeric chars is percent-encoded.\n//\nfunction getEncodeCache (exclude) {\n  let cache = encodeCache[exclude];\n  if (cache) { return cache }\n\n  cache = encodeCache[exclude] = [];\n\n  for (let i = 0; i < 128; i++) {\n    const ch = String.fromCharCode(i);\n\n    if (/^[0-9a-z]$/i.test(ch)) {\n      // always allow unencoded alphanumeric characters\n      cache.push(ch);\n    } else {\n      cache.push('%' + ('0' + i.toString(16).toUpperCase()).slice(-2));\n    }\n  }\n\n  for (let i = 0; i < exclude.length; i++) {\n    cache[exclude.charCodeAt(i)] = exclude[i];\n  }\n\n  return cache\n}\n\n// Encode unsafe characters with percent-encoding, skipping already\n// encoded sequences.\n//\n//  - string       - string to encode\n//  - exclude      - list of characters to ignore (in addition to a-zA-Z0-9)\n//  - keepEscaped  - don't encode '%' in a correct escape sequence (default: true)\n//\nfunction encode (string, exclude, keepEscaped) {\n  if (typeof exclude !== 'string') {\n    // encode(string, keepEscaped)\n    keepEscaped = exclude;\n    exclude = encode.defaultChars;\n  }\n\n  if (typeof keepEscaped === 'undefined') {\n    keepEscaped = true;\n  }\n\n  const cache = getEncodeCache(exclude);\n  let result = '';\n\n  for (let i = 0, l = string.length; i < l; i++) {\n    const code = string.charCodeAt(i);\n\n    if (keepEscaped && code === 0x25 /* % */ && i + 2 < l) {\n      if (/^[0-9a-f]{2}$/i.test(string.slice(i + 1, i + 3))) {\n        result += string.slice(i, i + 3);\n        i += 2;\n        continue\n      }\n    }\n\n    if (code < 128) {\n      result += cache[code];\n      continue\n    }\n\n    if (code >= 0xD800 && code <= 0xDFFF) {\n      if (code >= 0xD800 && code <= 0xDBFF && i + 1 < l) {\n        const nextCode = string.charCodeAt(i + 1);\n        if (nextCode >= 0xDC00 && nextCode <= 0xDFFF) {\n          result += encodeURIComponent(string[i] + string[i + 1]);\n          i++;\n          continue\n        }\n      }\n      result += '%EF%BF%BD';\n      continue\n    }\n\n    result += encodeURIComponent(string[i]);\n  }\n\n  return result\n}\n\nencode.defaultChars = \";/?:@&=+$,-_.!~*'()#\";\nencode.componentChars = \"-_.!~*'()\";\n\nfunction format (url) {\n  let result = '';\n\n  result += url.protocol || '';\n  result += url.slashes ? '//' : '';\n  result += url.auth ? url.auth + '@' : '';\n\n  if (url.hostname && url.hostname.indexOf(':') !== -1) {\n    // ipv6 address\n    result += '[' + url.hostname + ']';\n  } else {\n    result += url.hostname || '';\n  }\n\n  result += url.port ? ':' + url.port : '';\n  result += url.pathname || '';\n  result += url.search || '';\n  result += url.hash || '';\n\n  return result\n}\n\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n//\n// Changes from joyent/node:\n//\n// 1. No leading slash in paths,\n//    e.g. in `url.parse('http://foo?bar')` pathname is ``, not `/`\n//\n// 2. Backslashes are not replaced with slashes,\n//    so `http:\\\\example.org\\` is treated like a relative path\n//\n// 3. Trailing colon is treated like a part of the path,\n//    i.e. in `http://example.org:foo` pathname is `:foo`\n//\n// 4. Nothing is URL-encoded in the resulting object,\n//    (in joyent/node some chars in auth and paths are encoded)\n//\n// 5. `url.parse()` does not have `parseQueryString` argument\n//\n// 6. Removed extraneous result properties: `host`, `path`, `query`, etc.,\n//    which can be constructed using other parts of the url.\n//\n\nfunction Url () {\n  this.protocol = null;\n  this.slashes = null;\n  this.auth = null;\n  this.port = null;\n  this.hostname = null;\n  this.hash = null;\n  this.search = null;\n  this.pathname = null;\n}\n\n// Reference: RFC 3986, RFC 1808, RFC 2396\n\n// define these here so at least they only have to be\n// compiled once on the first module load.\nconst protocolPattern = /^([a-z0-9.+-]+:)/i;\nconst portPattern = /:[0-9]*$/;\n\n// Special case for a simple path URL\n/* eslint-disable-next-line no-useless-escape */\nconst simplePathPattern = /^(\\/\\/?(?!\\/)[^\\?\\s]*)(\\?[^\\s]*)?$/;\n\n// RFC 2396: characters reserved for delimiting URLs.\n// We actually just auto-escape these.\nconst delims = ['<', '>', '\"', '`', ' ', '\\r', '\\n', '\\t'];\n\n// RFC 2396: characters not allowed for various reasons.\nconst unwise = ['{', '}', '|', '\\\\', '^', '`'].concat(delims);\n\n// Allowed by RFCs, but cause of XSS attacks.  Always escape these.\nconst autoEscape = ['\\''].concat(unwise);\n// Characters that are never ever allowed in a hostname.\n// Note that any invalid chars are also handled, but these\n// are the ones that are *expected* to be seen, so we fast-path\n// them.\nconst nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape);\nconst hostEndingChars = ['/', '?', '#'];\nconst hostnameMaxLen = 255;\nconst hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/;\nconst hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/;\n// protocols that can allow \"unsafe\" and \"unwise\" chars.\n// protocols that never have a hostname.\nconst hostlessProtocol = {\n  javascript: true,\n  'javascript:': true\n};\n// protocols that always contain a // bit.\nconst slashedProtocol = {\n  http: true,\n  https: true,\n  ftp: true,\n  gopher: true,\n  file: true,\n  'http:': true,\n  'https:': true,\n  'ftp:': true,\n  'gopher:': true,\n  'file:': true\n};\n\nfunction urlParse (url, slashesDenoteHost) {\n  if (url && url instanceof Url) return url\n\n  const u = new Url();\n  u.parse(url, slashesDenoteHost);\n  return u\n}\n\nUrl.prototype.parse = function (url, slashesDenoteHost) {\n  let lowerProto, hec, slashes;\n  let rest = url;\n\n  // trim before proceeding.\n  // This is to support parse stuff like \"  http://foo.com  \\n\"\n  rest = rest.trim();\n\n  if (!slashesDenoteHost && url.split('#').length === 1) {\n    // Try fast path regexp\n    const simplePath = simplePathPattern.exec(rest);\n    if (simplePath) {\n      this.pathname = simplePath[1];\n      if (simplePath[2]) {\n        this.search = simplePath[2];\n      }\n      return this\n    }\n  }\n\n  let proto = protocolPattern.exec(rest);\n  if (proto) {\n    proto = proto[0];\n    lowerProto = proto.toLowerCase();\n    this.protocol = proto;\n    rest = rest.substr(proto.length);\n  }\n\n  // figure out if it's got a host\n  // user@server is *always* interpreted as a hostname, and url\n  // resolution will treat //foo/bar as host=foo,path=bar because that's\n  // how the browser resolves relative URLs.\n  /* eslint-disable-next-line no-useless-escape */\n  if (slashesDenoteHost || proto || rest.match(/^\\/\\/[^@\\/]+@[^@\\/]+/)) {\n    slashes = rest.substr(0, 2) === '//';\n    if (slashes && !(proto && hostlessProtocol[proto])) {\n      rest = rest.substr(2);\n      this.slashes = true;\n    }\n  }\n\n  if (!hostlessProtocol[proto] &&\n      (slashes || (proto && !slashedProtocol[proto]))) {\n    // there's a hostname.\n    // the first instance of /, ?, ;, or # ends the host.\n    //\n    // If there is an @ in the hostname, then non-host chars *are* allowed\n    // to the left of the last @ sign, unless some host-ending character\n    // comes *before* the @-sign.\n    // URLs are obnoxious.\n    //\n    // ex:\n    // http://a@b@c/ => user:a@b host:c\n    // http://a@b?@c => user:a host:c path:/?@c\n\n    // v0.12 TODO(isaacs): This is not quite how Chrome does things.\n    // Review our test case against browsers more comprehensively.\n\n    // find the first instance of any hostEndingChars\n    let hostEnd = -1;\n    for (let i = 0; i < hostEndingChars.length; i++) {\n      hec = rest.indexOf(hostEndingChars[i]);\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {\n        hostEnd = hec;\n      }\n    }\n\n    // at this point, either we have an explicit point where the\n    // auth portion cannot go past, or the last @ char is the decider.\n    let auth, atSign;\n    if (hostEnd === -1) {\n      // atSign can be anywhere.\n      atSign = rest.lastIndexOf('@');\n    } else {\n      // atSign must be in auth portion.\n      // http://a@b/c@d => host:b auth:a path:/c@d\n      atSign = rest.lastIndexOf('@', hostEnd);\n    }\n\n    // Now we have a portion which is definitely the auth.\n    // Pull that off.\n    if (atSign !== -1) {\n      auth = rest.slice(0, atSign);\n      rest = rest.slice(atSign + 1);\n      this.auth = auth;\n    }\n\n    // the host is the remaining to the left of the first non-host char\n    hostEnd = -1;\n    for (let i = 0; i < nonHostChars.length; i++) {\n      hec = rest.indexOf(nonHostChars[i]);\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {\n        hostEnd = hec;\n      }\n    }\n    // if we still have not hit it, then the entire thing is a host.\n    if (hostEnd === -1) {\n      hostEnd = rest.length;\n    }\n\n    if (rest[hostEnd - 1] === ':') { hostEnd--; }\n    const host = rest.slice(0, hostEnd);\n    rest = rest.slice(hostEnd);\n\n    // pull out port.\n    this.parseHost(host);\n\n    // we've indicated that there is a hostname,\n    // so even if it's empty, it has to be present.\n    this.hostname = this.hostname || '';\n\n    // if hostname begins with [ and ends with ]\n    // assume that it's an IPv6 address.\n    const ipv6Hostname = this.hostname[0] === '[' &&\n        this.hostname[this.hostname.length - 1] === ']';\n\n    // validate a little.\n    if (!ipv6Hostname) {\n      const hostparts = this.hostname.split(/\\./);\n      for (let i = 0, l = hostparts.length; i < l; i++) {\n        const part = hostparts[i];\n        if (!part) { continue }\n        if (!part.match(hostnamePartPattern)) {\n          let newpart = '';\n          for (let j = 0, k = part.length; j < k; j++) {\n            if (part.charCodeAt(j) > 127) {\n              // we replace non-ASCII char with a temporary placeholder\n              // we need this to make sure size of hostname is not\n              // broken by replacing non-ASCII by nothing\n              newpart += 'x';\n            } else {\n              newpart += part[j];\n            }\n          }\n          // we test again with ASCII char only\n          if (!newpart.match(hostnamePartPattern)) {\n            const validParts = hostparts.slice(0, i);\n            const notHost = hostparts.slice(i + 1);\n            const bit = part.match(hostnamePartStart);\n            if (bit) {\n              validParts.push(bit[1]);\n              notHost.unshift(bit[2]);\n            }\n            if (notHost.length) {\n              rest = notHost.join('.') + rest;\n            }\n            this.hostname = validParts.join('.');\n            break\n          }\n        }\n      }\n    }\n\n    if (this.hostname.length > hostnameMaxLen) {\n      this.hostname = '';\n    }\n\n    // strip [ and ] from the hostname\n    // the host field still retains them, though\n    if (ipv6Hostname) {\n      this.hostname = this.hostname.substr(1, this.hostname.length - 2);\n    }\n  }\n\n  // chop off from the tail first.\n  const hash = rest.indexOf('#');\n  if (hash !== -1) {\n    // got a fragment string.\n    this.hash = rest.substr(hash);\n    rest = rest.slice(0, hash);\n  }\n  const qm = rest.indexOf('?');\n  if (qm !== -1) {\n    this.search = rest.substr(qm);\n    rest = rest.slice(0, qm);\n  }\n  if (rest) { this.pathname = rest; }\n  if (slashedProtocol[lowerProto] &&\n      this.hostname && !this.pathname) {\n    this.pathname = '';\n  }\n\n  return this\n};\n\nUrl.prototype.parseHost = function (host) {\n  let port = portPattern.exec(host);\n  if (port) {\n    port = port[0];\n    if (port !== ':') {\n      this.port = port.substr(1);\n    }\n    host = host.substr(0, host.length - port.length);\n  }\n  if (host) { this.hostname = host; }\n};\n\nexports.decode = decode;\nexports.encode = encode;\nexports.format = format;\nexports.parse = urlParse;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}